<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Dodgy Chaos - thomasm1248 - GitHub</title>
    <link type="text/css" rel="stylesheet" href="webapp.css">
</head>
<body>
    <canvas id="canvas" class="fullscreen-canvas"></canvas>
    <script>




var canvas = document.getElementById("canvas");
var ctx = canvas.getContext("2d");

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

var animator =
    window.requestAnimationFrame ||
    window.mozRequestAnimationFrame ||
    window.webkitRequestAnimationFrame ||
    window.msRequestAnimationFrame;

var mouseX = 0, mouseY = 0;
var px = 200, py = 200;
var speed = 2;
var shrinkTimer = 0;
var loose = false;
var gameIsOver = false;

var Dot;
var dots = [];

var Enemy;
var enemies = [];

function dist(x1, y1, x2, y2) {
    var difx = x2 - x1;
    var dify = y2 - y1;

    return Math.sqrt(Math.pow(difx, 2) + Math.pow(dify, 2));
}











Dot = function() {
    do {
        this.x = Math.random() * canvas.width;
        this.y = Math.random() * canvas.height;
    } while(dist(this.x, this.y, px, py) < 200);

    this.mx = 0;
    this.my = 0;

    this.speed = 0.1;

    this.chasing = false;

    this.used = false;
}

Dot.prototype.draw = function() {
    ctx.save();
    ctx.translate(this.x, this.y);

    ctx.fillRect(-10, -10, 20, 20);

    ctx.restore();
}

Dot.prototype.move = function() {
    var dis = dist(this.x, this.y, px, py);

    if(this.chasing) {
        /*this.x += (px - this.x) / dis * this.speed;
        this.y += (py - this.y) / dis * this.speed;*/

        var difx = px - this.x;
        var dify = py - this.y;

        var offx = difx - this.mx;
        var offy = dify - this.my;

        dis = dist(this.mx, this.my, difx, dify);

        this.mx += offx / dis * this.speed;
        this.my += offy / dis * this.speed;
    } else if(dis < 200) {
        this.chasing = true;
    }

    this.x += this.mx;
    this.y += this.my;

    this.x += 50;
    this.y += 50;
    this.x += canvas.width + 100;
    this.y += canvas.height + 100;
    this.x %= canvas.width + 100;
    this.y %= canvas.height + 100;
    this.x -= 50;
    this.y -= 50;
}

Dot.prototype.checkColls = function() {
    for(var i = 0; i < dots.length; i++) {
        if(this.x === dots[i].x && this.y === dots[i].y) {
            continue;
        }

        if(dist(this.x, this.y, dots[i].x, dots[i].y) < 10) {
            this.used = true;
            dots[i].used = true;
            break;
        }
    }

    for(var i = 0; i < enemies.length; i++) {
        if(dist(this.x, this.y, enemies[i].x, enemies[i].y) < 40) {
            this.used = true;
            enemies[i].dead = true;
            break;
        }
    }
}

Dot.prototype.update = function() {
    this.move();
    this.checkColls();
    this.draw();

    if(this.used) {
        ctx.beginPath();
        ctx.arc(this.x, this.y, 25, 0, 2 * Math.PI);
        ctx.fill();
    }

    return this.used;
}











Enemy = function() {
    do {
        this.x = Math.random() * canvas.width;
        this.y = Math.random() * canvas.height;
    } while(dist(this.x, this.y, px, py) < 200);

    this.mx = Math.random() * 6 - 3;
    this.my = Math.random() * 6 - 3;

    this.dead = false;
}

Enemy.prototype.draw = function() {
    ctx.save();
    ctx.translate(this.x, this.y);

    var a = 50;
    var b = 15;
    ctx.beginPath();
    ctx.moveTo(-a, 0);
    ctx.lineTo(-b, -b);
    ctx.lineTo(0, -a);
    ctx.lineTo(b, -b);
    ctx.lineTo(a, 0);
    ctx.lineTo(b, b);
    ctx.lineTo(0, a);
    ctx.lineTo(-b, b);
    ctx.lineTo(-a, 0);
    ctx.fill();

    ctx.restore();
}

Enemy.prototype.move = function() {
    this.x += this.mx;
    this.y += this.my;

    this.x += 50;
    this.y += 50;
    this.x += canvas.width + 100;
    this.y += canvas.height + 100;
    this.x %= canvas.width + 100;
    this.y %= canvas.height + 100;
    this.x -= 50;
    this.y -= 50;
}

Enemy.prototype.update = function() {
    this.move();
    this.draw();

    if(this.dead) {
        ctx.beginPath();
        ctx.arc(this.x, this.y, 70, 0, 2 * Math.PI);
        ctx.fill();
    }

    return this.dead;
}











function updateDots() {
    if(Math.random() * 100 < 1.5 && canvas.width * canvas.height > 90000) {
        dots.push(new Dot());
    }

    for(var i = 0; i < dots.length; i++) {
        if(dots[i].update()) {
            dots.splice(i, 1);
            i--;
        }
    }
}

function updateEnemies() {
    if(Math.random() * 100 < 1.0 && canvas.width * canvas.height > 90000) {
        enemies.push(new Enemy());
    }

    for(var i = 0; i < enemies.length; i++) {
        if(enemies[i].update()) {
            enemies.splice(i, 1);
            i--;
        }
    }
}

function playing() {
    if(shrinkTimer < 0) {
        canvas.width -= 1;
        canvas.height -= 1;
        shrinkTimer = 10;
    }
    shrinkTimer--;

    ctx.fillStyle = "black";
    ctx.shadowColor = "#ffffff";
    ctx.shadowBlur = 30;
    ctx.shadowOffsetX = 0;
    ctx.shadowOffsetY = 0;

    ctx.fillRect(0, 0, canvas.width, canvas.height);

    px += (mouseX - px) / 10;
    py += (mouseY - py) / 10;

    ctx.beginPath();
    ctx.arc(px, py, 30, 0, 2 * Math.PI);
    ctx.fill();

    updateEnemies();
    updateDots();

    for(var i = 0; i < dots.length; i++) {
        if(dist(px, py, dots[i].x, dots[i].y) < 40) {
            loose = true;
            gameIsOver = true;
            break;
        }
    }

    for(var i = 0; i < enemies.length; i++) {
        if(dist(px, py, enemies[i].x, enemies[i].y) < 60) {
            loose = true;
            gameIsOver = true;
            break;
        }
    }

    if(canvas.width * canvas.height <= 90000) {
        gameIsOver = true;
    }

    if(gameIsOver) {
        ctx.globalAlpha = 0.01;
        ctx.shadowBlur = 0;
        if(loose) {
            ctx.fillStyle = "black";
            animator(gameOver);
        } else {
            ctx.fillStyle = "white";
            animator(gameOver);
        }
    } else {
        animator(playing);
    }
}

function gameOver() {
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    animator(gameOver);
}

canvas.addEventListener("mousemove", mousemove);

function mousemove(e) {
	var rect = canvas.getBoundingClientRect();

	mouseX = e.clientX - rect.left;
	mouseY = e.clientY - rect.top;
}

playing();




    </script>
</body>
</html>
